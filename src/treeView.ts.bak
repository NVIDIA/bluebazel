/////////////////////////////////////////////////////////////////////////////////////////
// MIT License
//
// Copyright (c) 2021-2023 NVIDIA Corporation
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
/////////////////////////////////////////////////////////////////////////////////////////
import { BazelService } from './services/bazel-service';
import { ConfigurationManager } from './services/configuration-manager';
import { MultiPropTreeItem } from './ui/multi-prop-tree-item';
import { SinglePropTreeItem } from './ui/single-prop-tree-item';
import { TreeItem } from 'vscode';
import * as vscode from 'vscode';

enum TargetType {
    BUILD = 'build',
    RUN = 'run',
    TEST = 'test'
}



const CONFIG_SECTIONS = {
    build: 'Build',
    run: 'Run',
    test: 'Test'
};

function getWorkspaceKeyUniqueToTarget(key: string, target: string): string {
    return `${key}For${target}`;
}


const WORKSPACE_KEYS = {
    buildTarget: 'buildTarget',
    runTarget: 'runTarget',
    testTarget: 'testTarget',
    buildEnvVars: 'buildEnvVar',
    runEnvVars: 'runEnvVars',
    testEnvVars: 'testEnvVars',
    buildConfigs: 'buildConfigs',
    runConfigs: 'runConfigs',
    testConfigs: 'testConfigs',
    bazelBuildArgs: 'bazelBuildArgs',
    bazelRunArgs: 'bazelRunArgs',
    bazelTestArgs: 'bazelTestArgs',
    runArgs: 'runArgs',
    testArgs: 'testArgs',
    setupEnvVars: 'setupEnvVars',
    targetSections: 'targetSections'
};

export class BazelTreeDataProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    _onDidChangeTreeData: vscode.EventEmitter<void> = new vscode.EventEmitter<void>();
    onDidChangeTreeData?: vscode.Event<void> = this._onDidChangeTreeData.event;

    context: vscode.ExtensionContext;

    m_configuration: ConfigurationManager;

    constructor(context: vscode.ExtensionContext,
        configuration: ConfigurationManager,
        private readonly bazelService: BazelService) {
        this.context = context;
        this.m_configuration = configuration;
    }

    getSections(): vscode.ProviderResult<vscode.TreeItem[]> {
        const customSections = this.m_configuration.getCustomButtons();
        const sectionTitles = Object.values(CONFIG_SECTIONS);

        const sectionMap: Map<string, number> =  new Map(sectionTitles.map((key, index) => [key, index]));

        const sections = sectionTitles.map(title => new TreeItem(title, vscode.TreeItemCollapsibleState.Collapsed));
        // for (const section of sections) {
        //     section.contextValue = section.label?.toString();
        //     if (section.contextValue === CONFIG_SECTIONS.build) {
        //         section.label = CONFIG_SECTIONS.build + ` ${this.bazelModel.getTarget(TargetType.BUILD).value}`;
        //     } else if (section.contextValue === CONFIG_SECTIONS.run) {
        //         section.label = CONFIG_SECTIONS.run + ` ${this.bazelModel.getTarget(TargetType.RUN).label}`;
        //     } else if (section.contextValue === CONFIG_SECTIONS.test) {
        //         section.label = CONFIG_SECTIONS.test + ` ${this.bazelModel.getTarget(TargetType.TEST).label}`;
        //     }
        // }
        customSections.forEach(element => {
            const sectionTitle = element.title;
            if (!sectionTitles.includes(sectionTitle)) {
                const collapse = element.collapsed ? vscode.TreeItemCollapsibleState.Collapsed :
                    vscode.TreeItemCollapsibleState.Expanded;
                const item = new TreeItem(sectionTitle, collapse);
                item.contextValue = sectionTitle;

                sections.push(item);
            } else {
                // This is one of the existing sessions.
                const idx = sectionMap.get(sectionTitle);
                if (idx !== undefined) {
                    sections[idx].collapsibleState = element.collapsed ? vscode.TreeItemCollapsibleState.Collapsed :
                        vscode.TreeItemCollapsibleState.Expanded;
                }
            }
        });

        return sections;
    }

    createButton(label: string, command: string, args: string[] | undefined = undefined, tooltip: string | undefined = undefined) {
        const treeItem = new TreeItem(label);
        treeItem.contextValue = 'CustomButton';

        if (tooltip !== undefined) {
            treeItem.tooltip = tooltip;
        }
        treeItem.command = { command: command, title: label, arguments: args };


        return treeItem;
    }

    getTreeItem(element: vscode.TreeItem): vscode.TreeItem | Thenable<vscode.TreeItem> {
        return element;
    }

    private getChildrenForSection(workspaceKeyConfig: string,
        workspaceKeyBazelArgs: string,
        workspaceKeyEnvVars: string,
        configType: string
    ): vscode.TreeItem[] {
        return [];
        // const envvar = new MultiPropTreeItem('Environment',
        //     workspaceKeyEnvVars,
        //     this.bazelModel,
        //     () => { this.refresh(); }
        // );

        // const config = new MultiPropTreeItem('Config',
        //     workspaceKeyConfig,
        //     this.bazelModel,
        //     () => { this.refresh(); },
        //     () => {
        //         return this.bazelService.fetchConfigsForAction(configType);
        //     }
        // );

        // const buildArgs = new MultiPropTreeItem('Args',
        //     workspaceKeyBazelArgs,
        //     this.bazelModel,
        //     () => { this.refresh(); }
        // );

        // return [config,
        //     buildArgs,
        //     envvar
        // ];
    }

    getChildren(element?: vscode.TreeItem | undefined): vscode.ProviderResult<vscode.TreeItem[]> {
        if (element === undefined) {
            // Refreshing the list. Make sure the custom buttons are updated.
            const sections = this.getSections();
            return sections;
        }
        else {

            if (element.contextValue === CONFIG_SECTIONS.build) {

                const buildSectionItems = this.getChildrenForSection(
                    WORKSPACE_KEYS.buildConfigs,
                    WORKSPACE_KEYS.bazelBuildArgs,
                    WORKSPACE_KEYS.buildEnvVars,
                    'build');

                const clean = new TreeItem('Clean');
                clean.contextValue = 'BuildClean';
                const format = new TreeItem('Format');
                format.contextValue = 'BuildFormat';
                buildSectionItems.push(...[
                    clean,
                    format
                ]);
                return buildSectionItems.concat(this.getCustomButtonsForSection(element.contextValue));
            }
            else if (element.contextValue === CONFIG_SECTIONS.run) {
                const runSectionItems = this.getChildrenForSection(
                    WORKSPACE_KEYS.runConfigs,
                    WORKSPACE_KEYS.bazelRunArgs,
                    WORKSPACE_KEYS.runEnvVars,
                    'run');
                const target = this.bazelModel.getTarget(TargetType.RUN).value;
                const runArgs = new SinglePropTreeItem('Run Args',
                    getWorkspaceKeyUniqueToTarget(WORKSPACE_KEYS.runArgs, target),
                    this.bazelModel,
                    () => { this.refresh(); }
                );

                const refreshRunTargets = new TreeItem('Refresh Run Targets');
                refreshRunTargets.contextValue = 'RefreshRunTargets';
                runSectionItems.push(...[ runArgs,
                    refreshRunTargets]);
                return runSectionItems.concat(this.getCustomButtonsForSection(element.contextValue));
            } else if (element.contextValue === CONFIG_SECTIONS.test) {
                const testSectionItems = this.getChildrenForSection(
                    WORKSPACE_KEYS.testConfigs,
                    WORKSPACE_KEYS.bazelTestArgs,
                    WORKSPACE_KEYS.testEnvVars,
                    'test');
                const target = this.bazelModel.getTarget(TargetType.TEST).value;
                const runArgs = new SinglePropTreeItem('Test Args',
                    getWorkspaceKeyUniqueToTarget(WORKSPACE_KEYS.testArgs, target),
                    this.bazelModel,
                    () => { this.refresh(); }
                );

                testSectionItems.push(runArgs);
                return testSectionItems.concat(this.getCustomButtonsForSection(element.contextValue));
            } else if (element.contextValue?.includes('MultiPropTreeItem')) {
                return (element as MultiPropTreeItem).getChildren();
            } else {
                if (element.label !== undefined) {
                    return this.getCustomButtonsForSection(element.label.toString());
                }
            }
        }
    }

    public refresh() {
        this._onDidChangeTreeData.fire();
    }

    private getCustomButtonsForSection(sectionName: string): Array<vscode.TreeItem> {
        const result: Array<vscode.TreeItem> = [];
        const customSections = this.m_configuration.getCustomButtons();
        customSections.forEach(section => {
            if (section.title == sectionName && section.buttons !== undefined) {
                // Create the buttons and return the list for this section
                section.buttons.forEach(customButton => {
                    result.push(this.createButton(customButton.title, customButton.methodName, [customButton.command], customButton.tooltip));
                });
            }
        });
        return result;
    }

}

